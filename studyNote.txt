2023.03.01 수요일

** 도메인 모델과 테이블 설계 
멤버가 오더를 만든다가 아니라.
오더를 만들 때 멤버가 필요하다. 라는 식의 생각이 필요하다.

1:다 다:1 관계에서는 다에 항상 FK가 있다.
ex) XFile , XDocument

* 외래 키가 있는 곳을 연관관계의 주인으로 정해라.

** 엔티티 클래스 개발 1,2

멤버가 오더스를 가진다.
오더스도 멤버를 가진다.
FK는 누가 업데이트 칠 것인가.
객체는 변경 포인트가 2곳인데, 테이블은 1곳이다.

연관관계 주인은 FK 있는 놈으로 하면 된다.

상속관계 전략을 잡아줘야한다. 그 전략은 추상 객체에 잡아줘야한다.

ex)Delivery, Order 
1:1 관계에서는 FK를 어디다 놓아도 된다.
일반적으로 접근하는 쪽에 FK를 놓는다.
Order의 Delivery 정보를 찾지.
Delivery를 잡고 Order정보를 찾는 경우는 드물기 때문에.

그럼 연관관계 주인도 FK를 가지는 Order로 잡아주면 된다.
* 연관관계 주인 잡아주기.
ex) Order객체의 테이블이 Delivery 테이블의 delivery_id를 FK로 가질 때,
Order 객체의 delivery field에 @JoinColumn(name = "delivery_id") annotation을 추가한다.
실무에서는 등록한 날짜도 넣고 뭐하면 ManyToMany는 못쓴다.
*
mappedby = "" 값은 field 값.
JoinColumn(name = "") 값은 컬럼 값.

* 엔티티 클래스 개발 1,2 모두 끝내고 점검하며 중요한거 찝어주겠다.
Getter는 열어두는게 편하다.
Setter는 상황이 다르다. Setter를 열어두면 나중에 어딘지 모르는 곳에서 자꾸 Entity를 수정한다.
그거 찾아내기가 힘들다.

그래서 엔티티를 변경할 떄는 Setter 대신에 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.
그래야 유지보수성이 확 올라간다.

table명 + id를 주로 쓴다. id로만 쓰면 나중에 헷갈려진다.
*

** 엔티티 설계시 주의점.

1. 엔티티에는 가급적이면 Setter를 사용하지 말자. (유지보수가 어려워진다.)
2. 모든 연관관계는 지연로딩으로 설정해야한다!!!**(매우중요)
	- 즉시로딩(EAGER)과 지연로딩이 있는데.
	- 즉시로딩은 연관된 애들을 다 불러온다.
		ex) Order를 불러올 때 연관된 OrderItem, Member 등등을 다 불러온다.
	- 모두 '지연로딩'(LAZY)으로 설정.
	- 연관된 엔티티를 함께 DB 조회 해야하면, fetch join또는 엔티티 그래프 기능을 사용한다.
	- @XToOne 은 기본이 EAGER이다. @XToMany는 기본이 LAZY이다.
3. 컬렉션은 필드에서 초기화 하자.
	- 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
	- null 문제에서 안전하다.
	- 하이버네이트는 엔티티를 영속화 할 때 컬렉션을 감싸서 내장 컬렉션으로 변경한다.

4. 테이블, 컬럼명 생성 전략.
	
2023.03.02

** 구현 요구 사항

** 애플리케이션 아키텍쳐
	- 개발 순서 : 서비스, 리포지토리 계층을 개발하고, 테스트 코드로 검증 후 웹(컨트롤러)쪽 개발	
	
** 회원 도메인 개발!


2023.03.08 수요일

회원 서비스 개발
** spring의 트랜잭셔널 어노테이션 써라.
** Autowired는 수정하기 어렵다.
** 요즘은 생성자 인젝션을 쓴다.

회원 서비스 테스트 만들기.

16분 54초까지 공부함.
** 더 나아간게 생성자를 자동으로 만들어주는 롬복꺼 @RequiredArgsConstructor를 쓴다.

2023.03.12 일요일

** 테스트 하는데 외부 디비를 사용한다. 이건 좋지 않다.
** 테스트 이후에는 모두 롤백이 되어야 좋다.
** 메모리 DB를 쓰는게 좋다.

2023.04.05

**어떻게 데이터를 수정하는게 올바른 방법인가.
	변경 감지와 병합(merge)를 통해 설명해보겠다.
	
2023.04.06
@NotEmpty 어노테이션을 쓰기 위해
참고로 스프링 부트 2.3 부터는 build.gradle에 다른 코드를 추가해야 합니다.
implementation 'org.springframework.boot:spring-boot-starter-validation'

2023.04.12

Api 스펙을 위한 dto를 만들어야한다.
왜냐면 Entity는 변경하는 경우가 많기 때문이다.
api를 만들떄는 Entity를 받지말라.

2023.04.16
대부분의 성능 문제는 조회 시에 일어난다.

2023.04.19
주문 + 배송정보 + 회원을 조회하는 API를 만들자.
지연로딩 때문에 발생하는 성능 문제를 단계적으로 해결해보자.

2023.04.25
엔티티를 외부로 노출하지 말라는게
Dto로 단순 감싸는게 아니라 안에 있는것도 다 dto로 하란소리다.
orderV2 함수를 봐라.
